\documentclass{../lecture}

\title{Lecture 2}
\date{January 21, 2026}

\begin{document}

\maketitle

\begin{frame}{Lecture Objectives}
  \begin{itemize}
    \item Understand what a build pipeline should do and what invariants it must respect
    \item Understand C compilation pipelines, environment variables, and the
      most common options to pass to the C compiler.
  \end{itemize}
\end{frame}

\begin{frame}{Invariants you need to respect}
  Build script behavior should be invariant to:
  \begin{itemize}
    \item The Invoker's working Directory
    \item External environment variables (unless explicitly specified as a
      parameter)
    \item Filesystem state across multiple runs
  \end{itemize}
  You want to avoid as many required conditions for running the program as
  possible (your ``users'' don't want to suffer in setup hell)
\end{frame}

\begin{frame}{Source vs Artifact Distinction}
  \begin{itemize}
    \item Source: all the code provided by the developers + build scripts
    \item Artifacts: anything generated by the build system
    \item If you deleted this file and rebuilt everything, do you get the same result?
    \item Would you commit this to your repository or gitignore it?
  \end{itemize}
\end{frame}

\begin{frame}{Host vs Target Distinction (From Lecture 1)}
  \begin{itemize}
    \item You are constructing a target system with different characteristics
      from your host system.
    \item Your goal is to construct a correct filesystem layout that has
      everything that you would expect in a basic Linux system:
      \begin{itemize}
        \item Programs
        \item Libraries
        \item Config files
        \item Directories (more on next slide)
      \end{itemize}
    \item Later we will use this to create a disk image.
  \end{itemize}
\end{frame}

\begin{frame}{Filesystem Hierarchy Standard}
It's probably good to go over this so you can pattern match paths described later.
\begin{itemize}
  \item Many build systems assume a conventional filesystem layout.
  \item We will be crafting a directory that contains a filesystem in this
    format (serves as the template for our disk image and initramfs)
  \item The most important directories for this course are:
    \begin{itemize}
      \item \texttt{/usr/include} — headers for userspace programs
      \item \texttt{/usr/lib} — libraries for userspace programs
      \item \texttt{/usr/bin} — executables for userspace programs
      \item \texttt{/etc} — system configuration
      \item \texttt{/lib} — critical runtime libraries
    \end{itemize}
  \item Build options like \texttt{--prefix=/usr} exist to target this layout.
\end{itemize}
\end{frame}

\section{C Dependency Management}

\begin{frame}[fragile]{C basics}
  \begin{itemize}
    \item Headers (Preprocessor takes them in)
    \item Objects and Libraries (Linker responsibilities)
  \end{itemize}
\lstinputlisting[language=c]{./depdemo/main.c}
\lstinputlisting[language=c]{./depdemo/helloworld.h}
\lstinputlisting[language=c]{./depdemo/helloworld.c}
\end{frame}

\begin{frame}[fragile]{The Build Process}
We first create libhelloworld.a, then tell the compiler where to find the
headers and implementations when compiling main
\lstinputlisting[language=bash]{./depdemo/build.sh}
\end{frame}

\begin{frame}{GCC Flags}
  Flags are passed to either make or configure as options or environment
  variables. They will be passed to \texttt{gcc} or \texttt{ld} as command-line
  arguments.
  
  See the lecture 2 handout for more information on how make works.
  \begin{block}{Compiler flags (CFLAGS and CPPFLAGS)}
    \begin{itemize}
      \item \texttt{-I/path/to/headers}
      \item -nostdinc (nuke include defaults)
    \end{itemize}
  \end{block}
  \begin{block}{Linker flags (LDFLAGS)}
    \begin{itemize}
      \item \texttt{-L/path/to/libraries}
      \item -static (link statically)
      \item \texttt{-l\{libraryname\}} (usually the build system takes care of this)
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]{Make}
  \begin{itemize}
    \item A build tool for C dependency management
    \item Prevents re-compiling files whose dependencies haven't changed.
  \end{itemize}
Below are some general patterns you can expect to use for make:
\begin{lstlisting}[language=bash]
# note make requires being in the same directory as the source code unless you use -C
# make with 8 parallel jobs
make -j8
# install to the default location (probably not what you want)
make -j8 install
# what you probably want, differs by source
make -j8 install DESTDIR=/path/to/rootfs
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{The build system from before with make}
You should also consult the handout about make to understand syntax specifics.
\lstinputlisting[language=make]{./depdemo/Makefile}
\end{frame}

\begin{frame}[fragile]{Automake}
  \begin{itemize}
    \item Is responsible for creating the \texttt{configure} scripts that you
      will often see in source tarballs
    \item \texttt{configure} scripts examine your system, the compiler you
      provided, what libraries are available, ...
    \item You need to provide proper environment variables and compile flags at
      this stage so it generates the proper Makefile.
    \item Often you want this stage to emit source files outside the source tree
    \item If you set flags after \texttt{./configure} it might be too late.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{A Sample Pipeline}
\lstinputlisting[language=bash]{./samplepipeline.sh}
\begin{itemize}
  \item Out of tree builds: build artifacts are kept separate from
    the source tree.
  \item Separation of concerns + certain programs (like gcc) only support out of
    tree builds.
\end{itemize}
\end{frame}

\begin{frame}{Libc}
  \begin{itemize}
    \item Basic POSIX headers like \texttt{<unistd.h>}, \texttt{<fcntl.h>},
      \texttt{<stdio.h>}, are implemented by a libc.
    \item Glibc is on most Linux distros (including your host machine)
    \item We will be using musl (friendly to static linking)
    \item You need to control your compile flags, environment variables, and
      options so glibc doesn't accidentally become a dependency in your binary.
  \end{itemize}
\end{frame}

\begin{frame}{Kernel Userspace Headers}
\begin{itemize}
  \item The Linux kernel provides a set of headers intended for \textbf{userspace}
        programs.
  \item These headers define syscalls, ioctl numbers, constants within the
    kernel, ...
  \item They live under paths like \texttt{linux/} and \texttt{asm/} (e.g.
        \texttt{<linux/stat.h>}).
  \item These headers are \textbf{not} part of libc, but libc depends on them.
  \item To build your libc, you will need to install these headers into your
    rootfs first (see handout for more info).
\end{itemize}
\end{frame}

\begin{frame}{Attack Plan for Bootstrapping Userspace}
  \begin{enumerate}
    \item Kernel Headers
    \item Libc (we use musl)
    \item Compile everything else
  \end{enumerate}
\end{frame}

\section{Up Next}

\begin{frame}{Up Next}
  \begin{itemize}
    \item Lab hours here immediately after lecture.
    \item We'll start going over:
      \begin{itemize}
        \item Kernel internals and options
        \item Why do you need an initramfs.
        \item Actually using qemu to boot up a system
      \end{itemize}
  \end{itemize}
\end{frame}

\end{document}
