\documentclass{../juni}

\author{Juni Kim}
\title{Lecture 3 Handout}
\date{January 23, 2026}

\begin{document}

\maketitle

\tableofcontents

\newpage

\section{Kernel Configuration}

To begin configuration, you should create a scratch directory (we highly
recommend this is a subdirectory of \texttt{\$DIST} since that is also mounted
in the external filesystem)

\begin{lstlisting}[language=bash]
cd /scratch/directory
make -C "/path/to/kernel/src" menuconfig O="/scratch/directory"
\end{lstlisting}

\subsection{Essential Kernel Configuration Options}

For this course, you will build a \emph{monolithic} kernel with a statically
embedded initramfs. This simplifies early boot debugging and avoids reliance on
kernel modules or an external root filesystem during bring-up.

\paragraph{Disabling Kernel Modules}

We recommend disabling loadable kernel modules entirely. This ensures all
drivers required for boot are built directly into the kernel image.

\begin{verbatim}
CONFIG_MODULES=n
\end{verbatim}

With this option disabled, the kernel will refuse to load modules at runtime,
and all required drivers must be enabled as built-ins.

\paragraph{Embedding a Custom Initramfs}

Your initramfs archive should be embedded directly into the kernel image at
build time. This archive is typically produced using \texttt{cpio} and
\texttt{gzip}.

\begin{verbatim}
CONFIG_INITRAMFS_SOURCE="/path/to/archive.cpio.gz"
\end{verbatim}

When this option is set, the kernel will unpack the archive into a temporary
root filesystem and execute \texttt{/init} as PID~1.

\paragraph{Kernel Command Line}

The kernel command line may be supplied in one of three ways:
\begin{itemize}
  \item explicitly via QEMU using \texttt{-append} when booting with
        \texttt{-kernel}
  \item by firmware (EFI) when booting from disk
  \item as a built-in default via kernel configuration
\end{itemize}

Since QEMU or firmware does not provide command line arguments by default, we
recommend supplying a default command line.

\begin{verbatim}
# please do not cargo cult this
CONFIG_CMDLINE="console=ttyYourChoice otherkey=option"
\end{verbatim}

On x86 only, you must also enable:

\begin{verbatim}
CONFIG_CMDLINE_BOOL=y
\end{verbatim}

This option enables the presence of a built-in command line on x86 systems,
even if it is empty.

\paragraph{Debugging the Command Line}

Assuming you have a working console but are suspicious about what parameters are
actually being passed to the kernel, you can always call

\begin{lstlisting}[language=bash]
cat /proc/cmdline
\end{lstlisting}

This assumes you have the \texttt{/proc} pseudofilesystem mounted on your
system.

\paragraph{EFI Support}

To support booting via UEFI firmware, the kernel must include the EFI stub and
EFI runtime support.

\begin{verbatim}
CONFIG_EFI=y
CONFIG_EFI_STUB=y
\end{verbatim}

With these options enabled, the kernel can be loaded directly by UEFI firmware
from disk without an intermediate bootloader.

\subsection{Required Serial Console Drivers}

Your kernel must include built-in drivers for the serial consoles used by the
virtual machines in this course. Disabling the wrong serial driver will result
in a silent boot with no visible output.

The following options must \emph{not} be disabled:

\begin{verbatim}
CONFIG_SERIAL_8250=y
CONFIG_SERIAL_8250_CONSOLE=y
\end{verbatim}

The above options provide the legacy PC serial port used by x86 virtual machines,
which appears as \texttt{/dev/ttyS0}.

\begin{verbatim}
CONFIG_SERIAL_AMBA_PL011=y
CONFIG_SERIAL_AMBA_PL011_CONSOLE=y
\end{verbatim}

The above options provide the ARM PL011 UART used by aarch64 virtual machines,
which appears as \texttt{/dev/ttyAMA0}.

\subsection{Virtio Device Support}

All virtual machines in this course use \texttt{virtio} devices for storage and
networking. You must ensure that virtio support is enabled in the kernel.

At a minimum, the following options must remain enabled:

\begin{verbatim}
CONFIG_VIRTIO=y
CONFIG_VIRTIO_PCI=y
CONFIG_VIRTIO_NET=y
\end{verbatim}

Disabling these options will cause virtual disks or network interfaces to
silently disappear, even though QEMU successfully emulates the hardware.

\subsection{Console Devices and \texttt{/dev/console}}

The specific serial device used by QEMU depends on the architecture:
\begin{itemize}
  \item aarch64 virtual machines use \texttt{/dev/ttyAMA0}
  \item x86\_64 virtual machines use \texttt{/dev/ttyS0}
\end{itemize}

Rather than hard-coding one of these device names in userspace, your
\texttt{/init} script should bind standard input, output, and error to
\texttt{/dev/console}.

\begin{lstlisting}[language=bash]
exec 0</dev/console 1>/dev/console 2>/dev/console
\end{lstlisting}

The kernel dynamically links \texttt{/dev/console} to the active serial console
specified by the kernel command line. This allows the same initramfs and
userspace to work across architectures without modification.

\newpage

\section{QEMU Invocation and Architecture Differences}

QEMU emulates hardware, not an operating system. As a result, different CPU
architectures require different machine models, firmware, and device options.
The commands below reflect the minimal sets of options required to boot systems
in this course.

If you are on x86, you should use \texttt{qemu-system-x86\_64}, and if you are
on arm you should use \texttt{qemu-system-aarch64}.

\subsection{Booting Directly with the Kernel}

In early stages of development, it is often convenient to boot QEMU directly
into a kernel without using firmware or a disk image.

\subsection{Exiting out of QEMU}

Press ctrl-a, followed by x while inside the qemu window. This will
automatically quit qemu. Once you have a real filesystem, you should probably
use \texttt{/bin/poweroff} instead.

\paragraph{Common Options}

\begin{itemize}
  \item \texttt{-m 1024} sets the amount of guest memory (in MB).
  \item \texttt{-kernel <path>} specifies the kernel binary to boot directly.
  \item \texttt{-nographic} disables graphical output and routes the console to
        the terminal.
  \item \texttt{-no-reboot} causes QEMU to exit instead of restarting on failure.
  \item \texttt{-netdev user,id=net0} and \texttt{-device virtio-net-pci}
        configure a virtual network interface.
\end{itemize}

\paragraph{aarch64-Specific Options}

\begin{itemize}
  \item \texttt{-machine virt} selects a generic virtual ARM machine model.
  \item \texttt{-cpu cortex-a72} selects a CPU model supported by the kernel.
  \item \texttt{-append "console=ttyAMA0"} directs kernel output to the serial
        console used by \texttt{-nographic}
\end{itemize}

\paragraph{x86\_64-Specific Options}

\begin{itemize}
  \item \texttt{-machine q35} selects a modern PCIe-based x86 machine model.
  \item \texttt{-append "console=ttyS0"} directs kernel output to the serial
        console used by \texttt{-nographic}
\end{itemize}

When booting directly with \texttt{-kernel}, the kernel is responsible for
initializing the system without firmware involvement.

\subsection{Booting from Disk Using Firmware}

Once a full disk image has been constructed, QEMU should be run using firmware
to more closely resemble a real system boot.

\paragraph{Firmware Options}

\begin{itemize}
  \item \texttt{-drive if=pflash,readonly=on,file=...CODE...} provides the
        read-only firmware image.
  \item \texttt{-drive if=pflash,file=...VARS...} provides writable firmware
        state (EFI variables).
\end{itemize}

The firmware binaries differ by architecture:
\begin{itemize}
  \item aarch64 uses \texttt{AAVMF\_CODE.fd} and \texttt{AAVMF\_VARS.fd}.
  \item x86\_64 uses \texttt{OVMF\_CODE\_4M.fd} and \texttt{OVMF\_VARS\_4M.fd}.
\end{itemize}

\paragraph{Disk and Console Options}

\begin{itemize}
  \item \texttt{-drive if=virtio,format=raw,file=<image>} attaches the bootable
        disk image.
  \item \texttt{-serial mon:stdio} multiplexes the serial console and QEMU
        monitor onto standard I/O.
  \item \texttt{-nographic} disables graphical output.
\end{itemize}

When booting via firmware, the kernel is loaded from disk by the firmware rather
than passed directly by QEMU.

\end{document}
